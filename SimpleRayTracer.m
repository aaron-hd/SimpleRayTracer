(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



SimpleRayTracer`$Version = 0.1;
SimpleRayTracer`$Published = False;


Print@"========================================================================
SimpleRayTracer package is being loaded. =============================
======================================================================="


BeginPackage["SimpleRayTracer`"];


Unprotect@@Names["SimpleRayTracer`*"];
ClearAll@@Names["SimpleRayTracer`*"];
Unprotect@@Names["SimpleRayTracer`Private`*"];
ClearAll@@Names["SimpleRayTracer`Private`*"];


$metric; $christoffel;
$t; $r; $\[Theta]; $\[Phi]; $v; $\[Chi];
$mass; $spin; $G0;
x; k; \[Lambda]; 


GetIntensityData::usage = 
"GetIntensityData[{rCam_?RationalQ,\[Theta]Cam_?RationalQ,\[Phi]Cam_?RationalQ}, paramRules_List, screenPoints_List, opts:OptionsPattern[]]";


GetRadiativeTransferEquationForDiskModel::usage = 
"GetRadiativeTransferEquationForDiskModel[{A_,\[Alpha]_,h_,l0_}] emplys a disk model from Gold et.Al '20 from which we quote:
A: controls the degree of absorption of the fluid
\[Alpha]: controls the frequency-dependence of the fluid emissivity, and consequently also the absorptivity
h: controls the scale-height of the accretion disk and therefore the vertical concentration of matter within the fluid
l0: specifies whether the fluid is rotating (l0 = 1) or purely radially infalling (l0 = 0)";


GetIntensity::usage = 
"GetIntensity[{rCam_?RationalQ,\[Theta]Cam_?RationalQ,\[Phi]Cam_?RationalQ},{xScreen_?RationalQ,yScreen_?RationalQ},paramRules_List,ode_, opts:OptionsPattern[]] numerically integrates the radiative transfer equation (ode) to obtain the intensity fror a single image point.
ode: radiative transfer equation (needs to be the output of GetRadiativeTransferEquationForDiskModel[])
for other input parameters, see GetSingleLightRay[]";


GetParametricShadowBoundary::usage = 
"GetParametricShadowBoundary[{rCam_,\[Theta]Cam_,\[Phi]Cam_}, {xCenter_,yCenter_}, radialSweepDistance_, {\[Psi]min_,\[Psi]max_,\[Psi]stepSize_}, paramRules_, precisionAim_]";


BoundaryBisection::usage = 
"BoundaryBisection[{rCam_,\[Theta]Cam_,\[Phi]Cam_}, {{xInnerScreen_,yInnerScreen_}, {xOuterScreen_,yOuterScreen_}}, paramRules_, precisionAim_]";


GetSingleLightRay::usage = 
"GetSingleLightRay[{rCam_,\[Theta]Cam_,\[Phi]Cam_},{xScreen_,yScreen_},paramRules_List]";


CheckConstantsOfMotionAlongRay::usage = 
"CheckConstantsOfMotionAlongRay[ray_,paramRules_]";


PlotSingleTrajectory::usage = 
"PlotSingleTrajectory[sol_, paramRules_List, opts:OptionsPattern[]]";


SetMetric::usage = 
"SetMetric[metricSymbol_Symbol]:: sets just the symbol of the metric which is to be used.\n
============================================================================================\n
SetMetric[metricSymbol, metricComponents, options:OptionsPattern[]]:: sets the metricSymbol and explicit metricComponents given as a List of dimension (4,4).\n
OPTIONS:\n
_______________________________________________________________________________\n
LowerQ->True (Specifies whether the user enters a metric with lower or upper indices. Standard Value is True, i.e., that the user enters with lower indices.";


GetMetric::usage = 
"GetMetric[]:: gets just the symbol of the metric which is currently declared.\n
============================================================================================\n
GetMetric[i,j]:: gets an explicit component (i,j) of the metric (or its inverse), where i and j have to be explicit indices, i.e., integers (-4,-3,-2,-1,1,2,3,4).";


SetBoyerLindquistCoords::usage = 
"SetCoordinates[t_Symbol, r_Symbol, \[Theta]_Symbol, \[Phi]_Symbol]:: sets the symbols to be used as BL coordinates.\n
============================================================================================
currently the camera is only set up for BL or Kerr coordinates!";

SetKerrCoords::usage = 
"SetCoordinates[v_Symbol, r_Symbol, \[Theta]_Symbol, \[Chi]_Symbolin]:: sets the list of symbols to be used as Kerr coordinates.\n
============================================================================================
currently the camera is only set up for BL or Kerr coordinates!";


GetBoyerLindquistCoords::usage = 
"GetBoyerLindquistCoords[]:: gets the list of symbols of the BL coordinates currently declared.\n
============================================================================================";

GetKerrCoords::usage = 
"GetKerrCoords[]:: gets the list of symbols of the Kerr coordinates currently declared.\n
============================================================================================";


SetMass::usage = 
"SetMass[mass_Symbol]:: sets the symbol that the user uses as the BH mass.\n
============================================================================================";

SetNewtonCoupling::usage = 
"SetMass[G0_Symbol]:: sets the symbol that the user uses as the the Newton coupling G0.\n
============================================================================================";

SetSpin::usage = 
"SetSpin[spin_Symbol]:: sets the symbol that the user uses as the BH spin.\n
============================================================================================";


SetChristoffel::usage = 
"SetChristoffel[christoffelSymbol_Symbol]:: sets just the symbol of the christoffel symbols which is to be used.\n
============================================================================================\n
SetChristoffel[christoffelSymbol, christoffelComponents, options:OptionsPattern[]]:: sets the christoffelSymbol and explicit christoffelComponents given as a List of dimension (4,4,4).\n
It only allows for input with one upper followed by two lower indices as the Christoffel is not a tensor.\n";


GetChristoffel::usage = 
"GetChristoffel[]:: gets just the symbol of the christoffel symbol which is currently declared.\n
============================================================================================\n
GetChristoffel[i,j,k]:: gets an explicit component (i,j,k) of the christoffel symbol, where i has to be an upper and j, k have to be lower indices, i.e., integers (1,2,3,4) and (-4,-3,-2,-1) respectively.";


GetNullGeodesic1stOrderODE::usage = 
"GetNullGeodesic1stOrderODE[]:: simply defines the lightlike geodesic equation as a 1st order system of 8 ODE's in terms of christoffel symbols with x as coordinates, k as wave-vectors and \[Lambda] as affine parameter.\n
Reference for implemented geodesic equation already cast into 1st order ODE: 1801.10452, Eq. (5) & (6).\n
============================================================================================\n
GetNullGeodesic1stOrderODE[pos, waveVector, affineParam]:: allows to define own notation for x, k and \[Lambda]";


GetBoyerLindquistInitialValues::usage = 
"GetBoyerLindquistInitialValues[{pos_Symbol, waveVector_Symbol, affineParam0_Symbol},{rObs_,\[Theta]Obs_,\[Phi]Obs_},{x_,y_},a_]:: defines appropriate initial conditions for an incident ray on a specific screen point\n
{pos_, waveVector_, affineParam0_} are the desired symbols for the coordinates, the waveVector an the initial value for the affine parameter.\n
{rObs,\[Theta]Obs,\[Phi]Obs} defines the precise location of the screen w.r.t. Boyer-Lindquist coordinates of the BH.\n
{x_,y_} defines the screen coordinates of the specific image point.\n
a_ is the impact parameter.\n
The implemented formula's follow 1607.05767, Sec. II C."


ConvertBoyerLindquistToCartesian::usage = 
"ConvertBoyerLindquistToCartesian[{r_,\[Theta]_,\[Phi]_}]:: converts a set of BL coordinates into a set of spatial cartesian coordinates."


PlotHorizon; PrintTemporaryOption; HorizonCondition; DiskCutoff; StopIntegrationAtLightRingNumber;RadiativeTransferMaxStepSize;


WhichCoords; Kerr; BoyerLindquist;


Begin["`Private`"];


(* ::Code::Initialization:: *)
(*a function to check whether something is an explicit index*)

ExplicitUpperIndexQ::usage = "ExplicitUpIndexQ[ind___] checks whether ind is an explicit upper index, i.e., if it is +1,+2,+3 or +4";

ExplicitUpperIndexQ[___] := False;
ExplicitUpperIndexQ[index_Integer/;1<=index<=4] := True;

ExplicitLowerIndexQ::usage = "ExplicitDownIndexQ[ind___] checks whether ind is an explicit lower index, i.e., if it is -1,-2,-3 or -4";

ExplicitLowerIndexQ[___] := False;
ExplicitLowerIndexQ[index_Integer/;-4<=index<=-1] := True;


RationalQ[___] := False;
RationalQ[a_?NumericQ/;Precision[a]===\[Infinity]] := True;


DynamicIterativeTaskTimeEstimatePrint[iterator_, iterativeTaskNumber_] := Module[
	{startTime},
	startTime = AbsoluteTime[];
	Print[
		"approx. ",
		Dynamic[DateDifference[DateList[startTime],DateList[startTime+((AbsoluteTime[] - startTime)/iterator*(iterativeTaskNumber - iterator))],{"Day","Hour","Minute","Second"}]],
		" left to finish calculation"
	];
];


SmoothHeaviside[r_,x_]:=(Tanh[x r]+1)/2;


SetMass[mass_Symbol] := Module[
	{},
	$mass = mass;
];

SetNewtonCoupling[G0_Symbol] := Module[
	{},
	$G0 = G0;
];

SetSpin[spin_Symbol] := Module[
	{},
	$spin = spin;
];


SetBoyerLindquistCoords[t_Symbol, r_Symbol, \[Theta]_Symbol, \[Phi]_Symbol] := Module[
	{},
	WhichCoords = BoyerLindquist;
	$t = t;
	$r = r;
	$\[Theta] = \[Theta];
	$\[Phi] = \[Phi];
];

GetBoyerLindquistCoords[] := {$t, $r, $\[Theta], $\[Phi]};


(* ::Input::Initialization:: *)
SetKerrCoords[v_Symbol, r_Symbol, \[Theta]_Symbol, \[Chi]_Symbol] := Module[
	{},
  WhichCoords = Kerr;
	$v = v;
	$r = r;
	$\[Theta] = \[Theta];
	$\[Chi] = \[Chi];
];

GetKerrCoords[] := {$v, $r, $\[Theta], $\[Chi]};


(* sets just the symbol of the metric to be used *)
SetMetric[metricSymbol_Symbol] := Module[
	{},
	$metric = metricSymbol;
];

(* use lower metric components as the standard input form *)
(* TODO: user should actively decide on lower or upper declaration *)
Options[SetMetric] = {LowerQ->True};
SetMetric::LowerQBoole="The value of LowerQ should be True or False. User input overriden and standard value 'True' is used.";

(* sets symbol and explicit components of the metric to be used *)
SetMetric[metricSymbol_Symbol, metricComponents_List/;Dimensions[metricComponents]=={4,4}, options:OptionsPattern[]]:= Module[
	{
		inverseMetricComponents = Inverse[metricComponents]
	},
	
	(* set the metric symbol *)
	$metric = metricSymbol;

	Switch[OptionValue[LowerQ],
		True
		,
		(*set the lower metric*)
		Do[
			$metric[-i,-j]=metricComponents[[i,j]],
			{i,4},{j,4}
		];
		(*set the upper metric*)
		Do[
			$metric[i,j]=inverseMetricComponents[[i,j]],
			{i,4},{j,4}
		];
		,
		False
		,
		(*set the upper metric*)
		Do[
			$metric[i,j]=metricComponents[[i,j]],
			{i,4},{j,4}
		];
		(*set the lower metric*)
		Do[
			$metric[-i,-j]=inverseMetricComponents[[i,j]],
			{i,4},{j,4}
		];
		,
		___,
		Message[f::LowerQBoole,b];
		(*set the lower metric*)
		Do[
			$metric[-i,-j]=metricComponents[[i,j]],
			{i,4},{j,4}
		];
		(*set the upper metric*)
		Do[
			$metric[i,j]=inverseMetricComponents[[i,j]],
			{i,4},{j,4}
		];
	];
];


(* gets the (previously set) metric *)

GetMetric[] := $metric;

(* gets a specific component of the (previously set) metric *)
GetMetric[i_/;Or[ExplicitUpperIndexQ@i,ExplicitLowerIndexQ@i],j_/;Or[ExplicitUpperIndexQ@j,ExplicitLowerIndexQ@j]] := $metric[i,j];


(* ::Code::Initialization:: *)
(* sets just the christoffel symbol w/o explicit values *)
SetChristoffel[christoffelSymbol_] := Module[
	{},
	$christoffel = christoffelSymbol;
];

(* sets the christoffel symbol christoffelSymbol in xAct notation and assigns the values from a (4,4,4)-dimensional list christoffelList of expressions*)
(* it only allows for input with one upper followed by two lower indices as the Christoffel is not a tensor *)

SetChristoffel[christoffelSymbol_, christoffelComponents_List/;Dimensions[christoffelComponents]=={4,4,4}] := Module[
	{},

	$christoffel = christoffelSymbol;

	Do[
		$christoffel = christoffelSymbol;
		christoffelSymbol[i,-j,-k] = christoffelComponents[[i,j,k]],
		{i,4},{j,4},{k,4}
	];
];


(* gets the (previously set) metric *)

GetChristoffel[] := $christoffel;

(* gets a specific component of the (previously set) metric *)
GetChristoffel[i_?ExplicitUpperIndexQ, j_?ExplicitLowerIndexQ, k_?ExplicitLowerIndexQ] := $christoffel[i,j,k];


CalculateChristoffelsFromMetric[];


(*simply defines the geodesic equation as a 1st order system of 8 ODE's in terms of christoffel symbols*)
(*GetNullGeodesic1stOrderODE[pos_, waveVector_, affineParam_] where pos is the symbol for the position, waveVector the symbol for the wave vector, and affineParam the affine parameter of the null geodesic*)
(*Reference for implemented geodesic Eq. cast into 1st order ODE: 1801.10452, Eq. (5) & (6).*)

GetNullGeodesic1stOrderODE[] := GetNullGeodesic1stOrderODE[x, k, \[Lambda]];

GetNullGeodesic1stOrderODE[pos_Symbol, waveVector_Symbol, affineParam_Symbol] := Module[
	{},
	Return[{
		D[pos[1][affineParam],affineParam]==waveVector[1][affineParam], 
		D[pos[2][affineParam],affineParam]==waveVector[2][affineParam], 
		D[pos[3][affineParam],affineParam]==waveVector[3][affineParam], 
		D[pos[4][affineParam],affineParam]==waveVector[4][affineParam],
		D[waveVector[1][affineParam],affineParam]==-Sum[GetChristoffel[1,-m,-n]*waveVector[m][affineParam]*waveVector[n][affineParam],{m,4},{n,4}],
		D[waveVector[2][affineParam],affineParam]==-Sum[GetChristoffel[2,-m,-n]*waveVector[m][affineParam]*waveVector[n][affineParam],{m,4},{n,4}],
		D[waveVector[3][affineParam],affineParam]==-Sum[GetChristoffel[3,-m,-n]*waveVector[m][affineParam]*waveVector[n][affineParam],{m,4},{n,4}],
		D[waveVector[4][affineParam],affineParam]==-Sum[GetChristoffel[4,-m,-n]*waveVector[m][affineParam]*waveVector[n][affineParam],{m,4},{n,4}]
	}]
];


ConvertBoyerLindquistToCartesian[{r_,theta_,phi_}]:={Sqrt[r^2 + $spin^2]*Sin[theta]*Cos[phi], Sqrt[r^2 + $spin^2]*Sin[theta]*Sin[phi],r*Cos[theta]};


(*this is to transform the observers screen coordinates (i.e., the initial conditions for the light rays) into standard Boyer-Lindquist (BL) coordinates of the BH*)
(*we follow 1607.05767, Sec. II C*)
(*the observer screen extends in the observers x and y coordinates with the origin at (0,rObs,\[Theta]Obs,\[Phi]Obs) in BL-coords, while the observers z-axis is aligned with the radial direction in BL-coords*)
(*a is the rotation parameter of the Kerr-BH (0 for Schwarzschild) *)

(*TODO: could be hard-coded to decrease computation time*)

(*get the spatial coordinates*)
GetBoyerLindquistToSceenCoordsRule[{r_,\[Theta]_,\[Phi]_},{rObs_,\[Theta]Obs_,\[Phi]Obs_},{x_,y_},a_] := Module[
	{\[Sigma],\[ScriptCapitalD],X,Y,Z},

	\[ScriptCapitalD] = Sin[\[Theta]Obs] Sqrt[rObs^2 + a^2] - y Cos[\[Theta]Obs];
	X = \[ScriptCapitalD] Cos[\[Phi]Obs] - x Sin[\[Phi]Obs];
	Y = \[ScriptCapitalD] Sin[\[Phi]Obs] + x Cos[\[Phi]Obs];
	Z = rObs Cos[\[Theta]Obs] + y Sin[\[Theta]Obs];
	\[Sigma] = (X^2 + Y^2 + Z^2 - a^2)/2;
	Return[{
		r ->  Sqrt[\[Sigma] + Sqrt[\[Sigma]^2 + a^2*Z^2]],
		\[Theta] -> ArcCos[Z/Sqrt[\[Sigma] + Sqrt[\[Sigma]^2 + a^2*Z^2]]],
		\[Phi] -> ArcTan[Y/X]
	}]
	
];

(*get the derivatives of the spatial coordinates*)
GetBoyerLindquistDerivativesToSceenCoordsRule[{r_,\[Theta]_,\[Phi]_},{rObs_,\[Theta]Obs_,\[Phi]Obs_},{x_,y_},a_] := Module[
	{\[Sigma],\[ScriptCapitalD],X,Y,Z,\[CapitalSigma],\[ScriptCapitalR],\[CapitalPhi]},
	
	(*definitions to obtain initial position*)
	\[ScriptCapitalD] = Sin[\[Theta]Obs] Sqrt[rObs^2 + a^2] - y Cos[\[Theta]Obs];
	X = \[ScriptCapitalD] Cos[\[Phi]Obs] - x Sin[\[Phi]Obs];
	Y = \[ScriptCapitalD] Sin[\[Phi]Obs] + x Cos[\[Phi]Obs];
	Z = rObs Cos[\[Theta]Obs] + y Sin[\[Theta]Obs];
	\[Sigma] = (X^2 + Y^2 + Z^2 - a^2)/2;
	(*definitions to obtain initial velocity*)
	\[CapitalSigma] = (r^2 + a^2*Cos[\[Theta]]^2);
	\[ScriptCapitalR] = (Sqrt[r^2 + a^2])/.{r:>Sqrt[\[Sigma] + Sqrt[\[Sigma]^2 + a^2*Z^2]]};
	\[CapitalPhi] = (\[Phi]-\[Phi]Obs)/.{\[Phi]->ArcTan[Y/X]};
	Return[{
		Der[r] ->  -((r*\[ScriptCapitalR]*Sin[\[Theta]]*Sin[\[Theta]Obs]*Cos[\[CapitalPhi]] + \[ScriptCapitalR]^2*Cos[\[Theta]]*Cos[\[Theta]Obs])/\[CapitalSigma]),
		Der[\[Theta]] -> -((\[ScriptCapitalR]*Cos[\[Theta]]*Sin[\[Theta]Obs]*Cos[\[CapitalPhi]] - r*Sin[\[Theta]]*Cos[\[Theta]Obs])/\[CapitalSigma]),
		Der[\[Phi]] -> (Sin[\[Theta]Obs]*Sin[\[CapitalPhi]]*Csc[\[Theta]])/\[ScriptCapitalR]
	}]
	
];

(*returns the initial position *)
(*\[Delta] is a constant which in (-,+,+,+) signature is 0 for light-like particles (photons), -1 for others, cf. 1607.05767. Since we only work with photons for now we use \[Delta]=0*)
GetBoyerLindquistInitialValues[{pos_Symbol, waveVector_Symbol, affineParam0_},{rObs_,\[Theta]Obs_,\[Phi]Obs_},{x_,y_},a_] := Module[
	{\[Beta], \[Gamma], covMetric = GetMetric[], xForSum, kForSum, \[Delta]=0, t=$t, r=$r, \[Theta]=$\[Theta], \[Phi]=$\[Phi]},

	xForSum = {None,r,\[Theta],\[Phi]};
	kForSum = {None,Der[r],Der[\[Theta]],Der[\[Phi]]};
	
	(*definitions to obtain initial time-component derivative*)
	\[Beta] = - (Sum[covMetric[-1,-i]*kForSum[[i]],{i,2,4}]/covMetric[-1,-1]);
	\[Gamma] = (\[Delta] - Sum[covMetric[-i,-j]*kForSum[[i]]*kForSum[[j]],{i,2,4},{j,2,4}])/covMetric[-1,-1];
	
	Return[{
		pos[1][affineParam0] == t,
		pos[2][affineParam0] == r,
		pos[3][affineParam0] == \[Theta],
		pos[4][affineParam0] == \[Phi],
		waveVector[1][affineParam0] == Der[t],
		waveVector[2][affineParam0] == Der[r],
		waveVector[3][affineParam0] == Der[\[Theta]],
		waveVector[4][affineParam0] == Der[\[Phi]]
	}/.{Der[t]-> \[Beta] + Sqrt[\[Beta]^2 + \[Gamma]], t->0}/.SimpleRayTracer`Private`GetBoyerLindquistDerivativesToSceenCoordsRule[{r,\[Theta],\[Phi]},{rObs,\[Theta]Obs,\[Phi]Obs},{x,y},a]/.SimpleRayTracer`Private`GetBoyerLindquistToSceenCoordsRule[{r,\[Theta],\[Phi]},{rObs,\[Theta]Obs,\[Phi]Obs},{x,y},a]]
]


(*this is to transform the standard Boyer-Lindquist (BL) coordinates of the BH into horizon-penetrating spherical ingoing Kerr (Kerr-Schild) coordinates*)
(*we follow Eq. (18-19) in 1811.04711*)

(*TODO: could be hard-coded to decrease computation time*)

GetKerrToBoyerLindquistCoordsRule[] := Module[
	{\[CapitalDelta] = $r^2 - 2 $G0 $mass $r + $spin^2},
	Return[{
		(*$r and $\[Theta] remain untransformed*)
		(*form from literature*)
		$v -> $t + $r + $G0 $mass Log[(-2 $G0 $mass $r+$r^2+$spin^2)/(4 $G0^2 $mass^2)]+($G0^2 $mass^2 Log[(-$G0 $mass+$r-Sqrt[$G0^2 $mass^2-$spin^2])/(-$G0 $mass+$r+Sqrt[$G0^2 $mass^2-$spin^2])])/Sqrt[$G0^2 $mass^2-$spin^2],
		Der[$v] -> Der[$t] + ($r^2+$spin^2)/(-2 $G0 $mass $r+$r^2+$spin^2) Der[$r],
		$\[Chi] -> $\[Phi] + $spin/(2Sqrt[$G0^2$mass^2 - $spin^2]) Log[($r-($mass+Sqrt[$G0^2$mass^2 - $spin^2]))/($r-($mass-Sqrt[$G0^2$mass^2 - $spin^2]))],
		Der[$\[Chi]] -> Der[$\[Phi]] + $spin/(-2 $G0 $mass $r+$r^2+$spin^2) Der[$r]
		(*self-determined form*)
		(*$v \[Rule] $t +$r+(2 $G0^2 $mass^2 ArcTan[(-$G0 $mass+$r)/Sqrt[-$G0^2 $mass^2+$spin^2]])/Sqrt[-$G0^2 $mass^2+$spin^2]+$G0 $mass Log[-2 $G0 $mass $r+$r^2+$spin^2],
		Der[$v] \[Rule] Der[$t] + ($r^2+$spin^2)/(-2 $G0 $mass $r+$r^2+$spin^2)Der[$r],
		$\[Chi] \[Rule] $\[Phi] +($spin ArcTan[(-$G0 $mass+$r)/Sqrt[-$G0^2 $mass^2+$spin^2]])/Sqrt[-$G0^2 $mass^2+$spin^2],
		Der[$\[Chi]] \[Rule] Der[$\[Phi]] + $spin/(-2 $G0 $mass $r+$r^2+$spin^2)Der[$r]*)
	}]
	
];

GetBoyerLindquistToKerrCoordsRule[] := Module[
	{\[CapitalDelta] = $r^2 - 2 $G0 $mass $r + $spin^2},
	Return[{
		(*$r and $\[Theta] remain untransformed*)
		(*form from literature*)
		$t -> $v - ($r+$G0 $mass Log[(-2 $G0 $mass $r+$r^2+$spin^2)/(4 $G0^2 $mass^2)]+($G0^2 $mass^2 Log[(-$G0 $mass+$r-Sqrt[$G0^2 $mass^2-$spin^2])/(-$G0 $mass+$r+Sqrt[$G0^2 $mass^2-$spin^2])])/Sqrt[$G0^2 $mass^2-$spin^2]),
		$\[Phi] -> $\[Chi] - $spin/(2Sqrt[$G0^2$mass^2 - $spin^2]) Log[($r-($mass+Sqrt[$G0^2$mass^2 - $spin^2]))/($r-($mass-Sqrt[$G0^2$mass^2 - $spin^2]))]
		(*self-determined form*)
		(*$t \[Rule] $v -$r-(2 $G0^2 $mass^2 ArcTan[(-$G0 $mass+$r)/Sqrt[-$G0^2 $mass^2+$spin^2]])/Sqrt[-$G0^2 $mass^2+$spin^2]-$G0 $mass Log[-2 $G0 $mass $r+$r^2+$spin^2],
		$\[Phi] \[Rule] $\[Chi] -($spin ArcTan[(-$G0 $mass+$r)/Sqrt[-$G0^2 $mass^2+$spin^2]])/Sqrt[-$G0^2 $mass^2+$spin^2]*)
	}]
	
];

(*there might be a more clever choice than t=0*)
GetKerrInitialValues[{pos_Symbol, waveVector_Symbol, affineParam0_},{rObs_,\[Theta]Obs_,\[Phi]Obs_},{x_,y_},a_] := Module[
	{\[Beta], \[Gamma], covMetric = GetMetric[], xForSum, kForSum, \[Delta]=0, t=$t, r=$r, \[Theta]=$\[Theta], \[Phi]=$\[Phi], v=$v, \[Chi]=$\[Chi]},

	xForSum = {None,r,\[Theta],\[Phi]};
	kForSum = {None,Der[r],Der[\[Theta]],Der[\[Phi]]};
	
	(*definitions to obtain initial time-component derivative*)
	\[Beta] = - (Sum[covMetric[-1,-i]*kForSum[[i]],{i,2,4}]/covMetric[-1,-1]);
	\[Gamma] = (\[Delta] - Sum[covMetric[-i,-j]*kForSum[[i]]*kForSum[[j]],{i,2,4},{j,2,4}])/covMetric[-1,-1];
	
	Return[{
		pos[1][affineParam0] == v,
		pos[2][affineParam0] == r,
		pos[3][affineParam0] == \[Theta],
		pos[4][affineParam0] == \[Chi],
		waveVector[1][affineParam0] == \[Beta] + Sqrt[\[Beta]^2 + \[Gamma]],
		waveVector[2][affineParam0] == Der[r],
		waveVector[3][affineParam0] == Der[\[Theta]],
		waveVector[4][affineParam0] == Der[\[Chi]]
	}/.SimpleRayTracer`Private`GetKerrToBoyerLindquistCoordsRule[]/.{t->0}/.SimpleRayTracer`Private`GetBoyerLindquistDerivativesToSceenCoordsRule[{r,\[Theta],\[Phi]},{rObs,\[Theta]Obs,\[Phi]Obs},{x,y},a]/.SimpleRayTracer`Private`GetBoyerLindquistToSceenCoordsRule[{r,\[Theta],\[Phi]},{rObs,\[Theta]Obs,\[Phi]Obs},{x,y},a]]
]


(*TODO: check whether a=0 in GetBoyerLindquistInitialValues is an ok coordinate choice for any metric*)
(*TODO: could implement check that metric contains no symbols except for coordinates and those specified in paramRules*)
Options[GetSingleLightRay] := Join[Options[NDSolve],{HorizonCondition->False}];
Options[GetSingleLightRayBL] := Join[Options[NDSolve],{HorizonCondition->False}];
Options[GetSingleLightRayKerr] := Join[Options[NDSolve],{HorizonCondition->False}];

SetOptions[GetSingleLightRay, WorkingPrecision->20];
SetOptions[GetSingleLightRayBL, WorkingPrecision->20];
SetOptions[GetSingleLightRayKerr, WorkingPrecision->20];

GetSingleLightRay[{rCam_,\[Theta]Cam_,\[Phi]Cam_},{xScreen_,yScreen_},paramRules_List, opts:OptionsPattern[]] := Module[{},
	Print["Input values of {rCam_,\[Theta]Cam_,\[Phi]Cam_} and/or {xScreen_,yScreen_} not recognized as infinite precision numbers. 
Please use rational input only as this improves the employed numerical methods. 
You can use Rationalize[input_,precision_]] where precision is the desired precision, e.g., 10^-100, to rationalize your numerical input."
	]
];

GetSingleLightRay[{rCam_?RationalQ,\[Theta]Cam_?RationalQ,\[Phi]Cam_?RationalQ},{xScreen_?RationalQ,yScreen_?RationalQ},paramRules_List, opts:OptionsPattern[]] := Module[
	{},
	Switch[
		(*condition*)
		WhichCoords,
		(*option 1*)
		BoyerLindquist,
		Return[GetSingleLightRayBL[{rCam,\[Theta]Cam,\[Phi]Cam},{xScreen,yScreen},paramRules, opts]],
		(*option 2*)
		Kerr,
		Return[GetSingleLightRayKerr[{rCam,\[Theta]Cam,\[Phi]Cam},{xScreen,yScreen},paramRules, opts]],
		(*default other*)
		_,
		Print["Suitable coordinates not yet set. Please use either SetBoyerLindquistCoords[] or SetKerrCoords[] to set the coordinates. Other coordinates are not yet supported."];
		Return[Null]		
	]
]


GetSingleLightRayBL[{rCam_?RationalQ,\[Theta]Cam_?RationalQ,\[Phi]Cam_?RationalQ},{xScreen_?RationalQ,yScreen_?RationalQ},paramRules_List, opts:OptionsPattern[]] := Module[
	{
		return = None,
		(*workingPrecision = OptionValue[WorkingPrecision],*)
		inits = GetBoyerLindquistInitialValues[{x, k, 0},{rCam,\[Theta]Cam,\[Phi]Cam},{xScreen,yScreen},$spin]/.Rationalize[paramRules,10^-100], 
		odes = Join[
			GetNullGeodesic1stOrderODE[x,k,\[Lambda]]/.{$t->x[1][\[Lambda]],$r->x[2][\[Lambda]],$\[Theta]->x[3][\[Lambda]],$\[Phi]->x[4][\[Lambda]]}/.Rationalize[paramRules,10^-100]
		], 
		\[Lambda]Max= 3rCam
	},
	
	return = (*Check[*)
		Catch[NDSolve[
			Join[odes, inits],
			{x[1][\[Lambda]],x[2][\[Lambda]],x[3][\[Lambda]],x[4][\[Lambda]],k[1][\[Lambda]],k[2][\[Lambda]],k[3][\[Lambda]],k[4][\[Lambda]]},{\[Lambda],0,\[Lambda]Max},
			Method -> {
				"EventLocator", 
				"Event" -> {
					x[2][\[Lambda]]>rCam*11/10,
					If[TrueQ[!OptionValue[HorizonCondition]],
						(Evaluate[Abs[1/GetMetric[2,2]/.Rationalize[paramRules,10^-100]]]/.{$t->x[1][\[Lambda]],$r->x[2][\[Lambda]],$\[Theta]->x[3][\[Lambda]],$\[Phi]->x[4][\[Lambda]]})>10^2(*(workingPrecision/10)*),
						(Evaluate[(OptionValue[HorizonCondition])/.Rationalize[paramRules,10^-100]]/.{$t->x[1][\[Lambda]],$r->x[2][\[Lambda]],$\[Theta]->x[3][\[Lambda]],$\[Phi]->x[4][\[Lambda]]})
					]
				}, 
				"EventAction" :> {
					(Print["trajectory escapes: at \[Lambda]="<>ToString[N[\[Lambda],5]]<>" the radial coordinate has surpassed the radial camera distance"]; 
					Throw[Null,"StopIntegration"])
					,
					If[
						TrueQ[!OptionValue[HorizonCondition]]
						,
						Print["trajectory fell into Killing horizon: at \[Lambda]=",N[\[Lambda],5]," the 1/\!\(\*SuperscriptBox[\(g\), \(rr\)]\) has surpassed 10^",2(*N[workingPrecision/10]*)," (chosen at rather random value). 
						If the event and Killing horizon differ, the user may pass on a horizon-condition $r($\[Theta]) via the option HorizonCondition->___.
						Also, note that very extreme spacetimes may have FALSELY been interpreted as a Killing horizon.
						Similarly, if the MaxStepSize is too large horizons may have not been detected."]; 
						,
						Print["trajectory fell into user defined horizon condition: at \[Lambda]=",N[\[Lambda],5],". Note that if the MaxStepSize is too large horizons may have not been detected. If in doubt, please check decreased MaxStepSize and ensure convergence."]
					];
					Throw[Null,"StopIntegration"]
				}
			},
			Sequence@@Evaluate[Cases[{opts},Rule[optName_,optVal_]/;MemberQ[Options[NDSolve][[All,1]],optName]]](*WorkingPrecision\[Rule]workingPrecision, MaxSteps\[Rule]1000000*)
		]](*,
		None
	]*);
	Return@return;
];


GetSingleLightRayKerr[{rCam_?RationalQ,\[Theta]Cam_?RationalQ,\[Phi]Cam_?RationalQ},{xScreen_?RationalQ,yScreen_?RationalQ},paramRules_List, opts:OptionsPattern[]] := Module[
	{
		return = None,
		inits = GetKerrInitialValues[{x, k, 0},{rCam,\[Theta]Cam,\[Phi]Cam},{xScreen,yScreen},$spin]/.Rationalize[paramRules,10^-100], 
		odes = Join[
			GetNullGeodesic1stOrderODE[x,k,\[Lambda]]/.{$v->x[1][\[Lambda]],$r->x[2][\[Lambda]],$\[Theta]->x[3][\[Lambda]],$\[Chi]->x[4][\[Lambda]]}/.Rationalize[paramRules,10^-100]
		], 
		\[Lambda]Max= 3rCam
	},
	
	return = (*Check[*)
		Catch[NDSolve[
			Join[odes, inits],
			{x[1][\[Lambda]],x[2][\[Lambda]],x[3][\[Lambda]],x[4][\[Lambda]],k[1][\[Lambda]],k[2][\[Lambda]],k[3][\[Lambda]],k[4][\[Lambda]]},{\[Lambda],0,\[Lambda]Max},
			Method -> {
				"EventLocator", 
				"Event" -> {
					x[2][\[Lambda]]>rCam*11/10,
					If[TrueQ[!OptionValue[HorizonCondition]],
						(Evaluate[Abs[1/GetMetric[2,2]/.Rationalize[paramRules,10^-100]]]/.{$v->x[1][\[Lambda]],$r->x[2][\[Lambda]],$\[Theta]->x[3][\[Lambda]],$\[Chi]->x[4][\[Lambda]]})>10^2(*(workingPrecision/10)*),
						(Evaluate[(OptionValue[HorizonCondition])/.Rationalize[paramRules,10^-100]]/.{$v->x[1][\[Lambda]],$r->x[2][\[Lambda]],$\[Theta]->x[3][\[Lambda]],$\[Chi]->x[4][\[Lambda]]})
					]
				}, 
				"EventAction" :> {
					(Print["trajectory escapes: at \[Lambda]="<>ToString[N[\[Lambda],5]]<>" the radial coordinate has surpassed the radial camera distance"]; 
					Throw[Null,"StopIntegration"])
					,
					If[
						TrueQ[!OptionValue[HorizonCondition]]
						,
						Print["trajectory fell into Killing horizon: at \[Lambda]=",N[\[Lambda],5]," the 1/\!\(\*SuperscriptBox[\(g\), \(rr\)]\) has surpassed 10^",2(*N[workingPrecision/10]*)," (chosen at rather random value). 
						If the event and Killing horizon differ, the user may pass on a horizon-condition $r($\[Theta]) via the option HorizonCondition->___.
						Also, note that very extreme spacetimes may have FALSELY been interpreted as a Killing horizon.
						Similarly, if the MaxStepSize is too large horizons may have not been detected."]; 
						,
						Print["trajectory fell into user defined horizon condition: at \[Lambda]=",N[\[Lambda],5],". Note that if the MaxStepSize is too large horizons may have not been detected. If in doubt, please check decreased MaxStepSize and ensure convergence."]
					];
					Throw[Null,"StopIntegration"]
				}
			},
			Sequence@@Evaluate[Cases[{opts},Rule[optName_,optVal_]/;MemberQ[Options[NDSolve][[All,1]],optName]]](*MaxStepSize\[Rule]1*^-2, MaxSteps\[Rule]1000000*)
		]](*,
		None
	]*);
	Return@return;
];


TrajectoryQ[___] := False;
TrajectoryQ[{
	x[1][\[Lambda]]->InterpolatingFunction[___][\[Lambda]],
	x[2][\[Lambda]]->InterpolatingFunction[___][\[Lambda]],
	x[3][\[Lambda]]->InterpolatingFunction[___][\[Lambda]],
	x[4][\[Lambda]]->InterpolatingFunction[___][\[Lambda]],
	k[1][\[Lambda]]->InterpolatingFunction[___][\[Lambda]],
	k[2][\[Lambda]]->InterpolatingFunction[___][\[Lambda]],
	k[3][\[Lambda]]->InterpolatingFunction[___][\[Lambda]],
	k[4][\[Lambda]]->InterpolatingFunction[___][\[Lambda]]
}] := True;

Options[PlotSingleTrajectory] := Join[Options[ParametricPlot3D],{PlotHorizon->False}];

PlotSingleTrajectory[sol_?TrajectoryQ, paramRules_List, opts:OptionsPattern[]] := Module[
	{
		plot,
		plotRangeVal,
		horizonCondition,
		xCartesian,yCartesian,zCartesian
	},
	(*determine a useful plot range unless user has passed their own*)
	If[
		OptionValue[PlotRange]===Automatic
		,
		Print["plot range obtained by doubling the radial distance at which angular coordinate \[Theta] changes most rapidly: use PlotRange option to set own plot range."];
		plotRangeVal = x[2][\[Lambda]]/.sol/.Last[Check[NMaximize[Evaluate[D[x[3][\[Lambda]]/.sol,\[Lambda]]],{\[Lambda],Head[sol[[3,2]]][[1,1,1]],Head[sol[[3,2]]][[1,1,2]]}],{None,{\[Lambda]->Head[sol[[3,2]]][[1,1,2]]}}]];
		plotRangeVal = Evaluate[{{-2,2},{-2,2},{-2,2}}plotRangeVal];
		,
		plotRangeVal = OptionValue[PlotRange];
	];

	(*create main plot of trajectory*)
	plot = ParametricPlot3D[
		Evaluate[ConvertBoyerLindquistToCartesian[{$r,$\[Theta],$\[Phi]}]//.Switch[
				WhichCoords,
				BoyerLindquist, {$t->x[1][\[Lambda]],$r->x[2][\[Lambda]],$\[Theta]->x[3][\[Lambda]],$\[Phi]->x[4][\[Lambda]]},
				Kerr, Join[GetBoyerLindquistToKerrCoordsRule[],{$v->x[1][\[Lambda]],$r->x[2][\[Lambda]],$\[Theta]->x[3][\[Lambda]],$\[Chi]->x[4][\[Lambda]]}],
				_,Print["Suitable coordinates not yet set. Please use either SetBoyerLindquistCoords[] or SetKerrCoords[] to set the coordinates. Other coordinates are not yet supported."];Break[];
			]/.paramRules/.sol],{\[Lambda],0,Head[sol[[1,-1]]][[1,1,-1]]},
		opts,
		PlotRange->plotRangeVal,
		PlotStyle->{Thick,Red}, PlotPoints->5000,
		AxesLabel->{"x", "y", "z"}, LabelStyle->{Black,16,FontFamily->"Helvetica"}, BoxStyle->Directive[{Black,Thick}]
	];

	(*plot horizon if user wants to*)
	Switch[
		OptionValue[PlotHorizon]
		,
		False
		,
		None;
		,
		_Graphics3D
		,
		plot = Show[
			plot, 
			OptionValue[PlotHorizon]
		];
		,
		True
		,
		PrintTemporary["PlotHorizon: horizon is determined numerically using 500 points at random angles to approximate a surface solving 1/\!\(\*SubscriptBox[\(g\), \(tt\)]\)==0 (might not be the generic horizon). You can change the number of points via PlotHorizon->numberOfPoints."];
		PrintTemporary["Alternatively, you can pass the horizon as a Graphics3D object, or predetermine the horizon via sol=NumericalHorizonSurfacePlot3D[paramRules_List, numberOfPoints_] and pass the result via PlotHorizon->sol."];
		plot = Show[
			plot, 
			SimpleRayTracer`Private`NumericalHorizonSurfacePlot3D[paramRules, 500]
		];
		,
		_Integer
		,
		PrintTemporary["PlotHorizon: horizon is determined numerically using "<>ToString@OptionValue[PlotHorizon]<>" points at random angles to approximate a surface solving 1/\!\(\*SubscriptBox[\(g\), \(tt\)]\)==0 (might not be the generic horizon)."];
		PrintTemporary["Alternatively, you can pass the horizon as a Graphics3D object, or predetermine the horizon via sol=NumericalHorizonSurfacePlot3D[paramRules_List, numberOfPoints_] and pass the result via PlotHorizon->sol."];
		plot = Show[
			plot, 
			SimpleRayTracer`Private`NumericalHorizonSurfacePlot3D[paramRules, OptionValue[PlotHorizon]]
		];
		,
		___
		,
		Print["PlotHorizon: no proper option value given. Please use True, False, an integer number of numerical horizon plot points, or a Graphics3D object"]
	];

	Return@plot;
];

PlotSingleTrajectory[sol_, paramRules_List, opts:OptionsPattern[]] := Module[{},
	Print["Looks like you input value for 'sol' is not a trajectory as generated by GetSingleLightRay[].
Please use the latter to generate a trajectory before attempting to plot."]
];

NumericalHorizonSurfacePlot3D[paramRules_List, numberOfPoints_]:=Module[
	{
		guess  = {$\[Theta]->\[Pi]/2,$\[Phi]->\[Pi],$r->Max[Join[{0.01},($r/.#)&/@Quiet@NSolve[(1/GetMetric[1,1]==0)/.paramRules/.{$\[Theta]->\[Pi]/2,$\[Phi]->\[Pi]/2},$r,Reals]]]}//N,
		discreteHorizonData,
		return,
		outermostGuess = 100,
		r=$r, \[Theta]=$\[Theta], \[Phi]=$\[Phi], aaa
	},
	Print@guess;
	
	DynamicModule[
		{
			counter=0,
			starttime = AbsoluteTime[]
		},
	
		PrintTemporary["determining plot points for numerical horizon ... "];
		PrintTemporary["estimated remaining time for evaluation: ", Dynamic[DateDifference[DateList[starttime],DateList[starttime+((AbsoluteTime[] - starttime)/counter*(numberOfPoints - counter))],{"Day","Hour","Minute","Second"}]]];

		discreteHorizonData = Join[#,
				counter=counter+1;
				FindRoot[
					Evaluate[Simplify[1/GetMetric[1,1]/.paramRules/.$r->aaa]/.#],{aaa,guess[[3,2]],outermostGuess}
				]
			]&/@Table[{\[Theta]->RandomReal[{0,\[Pi]}], \[Phi]->RandomReal[{0,2\[Pi]}]},{count,numberOfPoints}];
	];

	discreteHorizonData = ({aaa*Sin[\[Theta]]Cos[\[Phi]],aaa*Sin[\[Theta]]Sin[\[Phi]],aaa*Cos[\[Theta]]}/.#)&/@discreteHorizonData;
	
	return = ListSurfacePlot3D[discreteHorizonData, PlotStyle->Directive[Black]];
	Return@return;
]


CheckConstantsOfMotionAlongRay[ray_,paramRules_,angMomVar_] := Module[
	{
		\[Lambda]Min= Head[ray[[1,2]]][[1,1,1]],
		\[Lambda]Max= Head[ray[[1,2]]][[1,1,2]],
		energy = Simplify[
				-Sum[GetMetric[-1,-j]k[j][\[Lambda]],{j,1,4}]/.paramRules,
				Trig->False
			]/.{$t->x[1][\[Lambda]],$r->x[2][\[Lambda]],$\[Theta]->x[3][\[Lambda]],$\[Phi]->x[4][\[Lambda]]}/.ray,
		angularMomentum = Simplify[
				Sum[GetMetric[-4,-j]k[j][\[Lambda]],{j,1,4}]/.paramRules,
				Trig->False
			]/.{$t->x[1][\[Lambda]],$r->x[2][\[Lambda]],$\[Theta]->x[3][\[Lambda]],$\[Phi]->x[4][\[Lambda]]}/.ray,
		carterConst = Simplify[
				(
					+ Sum[GetMetric[-3,-j]k[j][\[Lambda]],{j,1,4}]^2
					+ Cos[x[3][\[Lambda]]]^2(
						- angMomVar^2*(Sum[GetMetric[-1,-j]k[j][\[Lambda]],{j,1,4}]^2)
						+ (Sum[GetMetric[-4,-j]k[j][\[Lambda]],{j,1,4}]^2)/(Sin[x[3][\[Lambda]]]^2)
						)
				)/.paramRules,
				Trig->False
			]/.{$t->x[1][\[Lambda]],$r->x[2][\[Lambda]],$\[Theta]->x[3][\[Lambda]],$\[Phi]->x[4][\[Lambda]]}/.ray,
		relativeErrorEnergy, relativeErrorAngularMomentum, relativeErrorCarterConstant
	},
	relativeErrorEnergy = If[(energy/.\[Lambda]->RandomReal[{\[Lambda]Min,\[Lambda]Max}]) == 0, 0, ((energy/.\[Lambda]->\[Lambda]Min) - (energy))/(energy/.\[Lambda]->\[Lambda]Min)];
	relativeErrorAngularMomentum = If[(angularMomentum/.\[Lambda]->RandomReal[{\[Lambda]Min,\[Lambda]Max}]) == 0, 0, ((angularMomentum/.\[Lambda]->\[Lambda]Min) - (angularMomentum))/(angularMomentum/.\[Lambda]->\[Lambda]Min)];
	relativeErrorCarterConstant = If[(carterConst/.\[Lambda]->RandomReal[{\[Lambda]Min,\[Lambda]Max}]) == 0, 0, ((carterConst/.\[Lambda]->\[Lambda]Min) - (carterConst))/(carterConst/.\[Lambda]->\[Lambda]Min)];
	
	If[relativeErrorEnergy === 0,
		Print["energy seems to vanish identically"];
		,
		Print@LogPlot[
			Evaluate[{Abs[energy],Abs[relativeErrorEnergy]}],
			{\[Lambda],\[Lambda]Min,\[Lambda]Max}, PlotRange->Full,
			PlotStyle->{{Thick,Red},{Dashed,Red}}, AspectRatio->1,ImageSize->350,
			Frame->True,PlotLabel->"energy",FrameLabel->{"affine parameter \[Lambda]","energy [relative error]"},LabelStyle->{Black,16},FrameStyle->{{Thick,Black}}
		];
	];
	
	If[relativeErrorAngularMomentum === 0,
		Print["angular momentum seems to vanish identically"];
		,
		Print@LogPlot[
			Evaluate[{Abs[angularMomentum],Abs[relativeErrorAngularMomentum]}],
			{\[Lambda],\[Lambda]Min,\[Lambda]Max},PlotRange->Full,
			PlotStyle->{{Thick,Red},{Dashed,Red}}, AspectRatio->1,ImageSize->350,
			Frame->True,PlotLabel->"angular momentum",FrameLabel->{"affine parameter \[Lambda]", "momentum [relative error]"},LabelStyle->{Black,16},FrameStyle->{{Thick,Black}}
		];
	];
	
	If[relativeErrorCarterConstant === 0,
		Print["Carter constant seems to vanish identically"];
		,
		Print@LogPlot[
			Evaluate[{Abs[carterConst],Abs[relativeErrorCarterConstant]}],
			{\[Lambda],\[Lambda]Min,\[Lambda]Max}, PlotRange->Full,
			PlotStyle->{{Thick,Red},{Dashed,Red}}, AspectRatio->1,ImageSize->350,
			Frame->True,PlotLabel->"Carter constant",FrameLabel->{"affine parameter \[Lambda]","Carter [relative error]"},LabelStyle->{Black,16},FrameStyle->{{Thick,Black}}
		];
	];

	{
		{"maximalErrors", NMaxValue[{Abs[relativeErrorEnergy],\[Lambda]Min<\[Lambda]<\[Lambda]Max},\[Lambda]], NMaxValue[{Abs[relativeErrorAngularMomentum],\[Lambda]Min<\[Lambda]<\[Lambda]Max},\[Lambda]], NMaxValue[{Abs[relativeErrorCarterConstant],\[Lambda]Min<\[Lambda]<\[Lambda]Max},\[Lambda]]},
		{"finalTimeErrors", Abs[relativeErrorEnergy/.{\[Lambda]->\[Lambda]Max}], Abs[relativeErrorAngularMomentum/.{\[Lambda]->\[Lambda]Max}], Abs[relativeErrorCarterConstant/.{\[Lambda]->\[Lambda]Max}]}
	}
]


Options[BoundaryBisection] := Join[{PrintTemporaryOption->True, HorizonCondition->False},Options[NDSolve]];

BoundaryBisection[{rCam_?RationalQ,\[Theta]Cam_?RationalQ,\[Phi]Cam_?RationalQ}, {{xInnerScreen_?RationalQ,yInnerScreen_?RationalQ}, {xOuterScreen_?RationalQ,yOuterScreen_?RationalQ}}, paramRules_, precisionAim_, opts:OptionsPattern[]] := Module[
	{
		inits, xScreen, yScreen,odes,
		\[Lambda]Max= 3rCam,
		result, return
	},
	
	Switch[
		(*condition*)
		WhichCoords,
		(*option 1*)
		BoyerLindquist,
		odes = GetNullGeodesic1stOrderODE[x,k,\[Lambda]]/.{$t->x[1][\[Lambda]],$r->x[2][\[Lambda]],$\[Theta]->x[3][\[Lambda]],$\[Phi]->x[4][\[Lambda]]}/.Rationalize[paramRules,10^-100];
		inits = GetBoyerLindquistInitialValues[{x, k, 0},{rCam,\[Theta]Cam,\[Phi]Cam},{xScreen,yScreen},0]/.Rationalize[paramRules,10^-100];
		,
		(*option 2*)
		Kerr,
		odes = GetNullGeodesic1stOrderODE[x,k,\[Lambda]]/.{$v->x[1][\[Lambda]],$r->x[2][\[Lambda]],$\[Theta]->x[3][\[Lambda]],$\[Chi]->x[4][\[Lambda]]}/.Rationalize[paramRules,10^-100];
		inits = GetKerrInitialValues[{x, k, 0},{rCam,\[Theta]Cam,\[Phi]Cam},{xScreen,yScreen},$spin]/.Rationalize[paramRules,10^-100];
		,
		(*default other*)
		_,
		Print["Suitable coordinates not yet set. Please use either SetBoyerLindquistCoords[] or SetKerrCoords[] to set the coordinates. Other coordinates are not yet supported."];
		Return[Null]		
	];
	
	If[OptionValue[PrintTemporaryOption], PrintTemporary["boundary bisection in progress ... using ",If[TrueQ[!OptionValue[HorizonCondition]],"any NDSolve error as indication for a ray falling into the horizon", "NDSolve errors and/or the user specified HorizonCondition as indication for a ray falling into the horizon"]]];
	result = BoundaryBisectionInternal[odes, inits, {\[Lambda],0,\[Lambda]Max}, {xScreen, yScreen}, {{xInnerScreen,yInnerScreen}, {xOuterScreen,yOuterScreen}}, paramRules, precisionAim, opts, PrintTemporaryOption->OptionValue[PrintTemporaryOption]];

	If[
		Or[
			(xOuterScreen - result[[1]])^2 + (yOuterScreen - result[[2]])^2 < 2*precisionAim^2,
			(xInnerScreen - result[[1]])^2 + (yInnerScreen - result[[2]])^2 < 2*precisionAim^2
		]
		,
		If[OptionValue[PrintTemporaryOption], Print["probably no shadow boundary between the two specified points."]];
		return = None;
		,
		If[OptionValue[PrintTemporaryOption], Print["shadow boundary was found within the specified interval."]];
		return = result;
	];

	Return@return;
];

BoundaryBisection[{rCam_,\[Theta]Cam_,\[Phi]Cam_}, {{xInnerScreen_,yInnerScreen_}, {xOuterScreen_,yOuterScreen_}}, paramRules_, precisionAim_, opts:OptionsPattern[]] := Module[{},
	Print["Input values of {rCam_,\[Theta]Cam_,\[Phi]Cam_} and/or {{xInnerScreen_,yInnerScreen_}, {xOuterScreen_,yOuterScreen_}} not recognized as infinite precision numbers. 
Please use rational input only as this improves the employed numerical methods. 
You can use Rationalize[input_,precision_]] where precision is the desired precision, e.g., 10^-100, to rationalize your numerical input."
	];
];


Options[BoundaryBisectionInternal] := Options[BoundaryBisection];

BoundaryBisectionInternal::HorizonCondition="Trajectory fell into user-defined horizon.";

BoundaryBisectionInternal[odes_, inits_, {\[Lambda]_,\[Lambda]Min_,\[Lambda]Max_}, {xScreen_, yScreen_}, {{xInnerScreen_,yInnerScreen_}, {xOuterScreen_,yOuterScreen_}}, paramRules_, precisionAim_, opts:OptionsPattern[]] := Module[
	{
		sol,
		stepNumber = 0
	},
	
	(*PrintTemporary[OptionValue[WorkingPrecision]];*)
	
	If[OptionValue[PrintTemporaryOption], 
		PrintTemporary["current bisection: x \[Element] ["<>ToString[N@xInnerScreen]<>","<>ToString[N@xOuterScreen]<>"] and y \[Element] [", N@yInnerScreen, ", ", N@yOuterScreen, "]."];
	];
	If[
		(xOuterScreen-xInnerScreen)^2 + (yOuterScreen-yInnerScreen)^2 > precisionAim^2
		,
		(*Print@If[TrueQ[!OptionValue[HorizonCondition]],"proceed without horizon condition", "apply horizon condition", "other"];*)
		sol = Check[
			Catch[NDSolve[
				Join[
					odes,
					inits/.{xScreen -> xInnerScreen + (xOuterScreen-xInnerScreen)/2, yScreen -> yInnerScreen + (yOuterScreen-yInnerScreen)/2}
				],
				{x[1][\[Lambda]],x[2][\[Lambda]],x[3][\[Lambda]],x[4][\[Lambda]],k[1][\[Lambda]],k[2][\[Lambda]],k[3][\[Lambda]],k[4][\[Lambda]]},{\[Lambda],\[Lambda]Min,\[Lambda]Max},
				Method -> If[TrueQ[!OptionValue[HorizonCondition]],Automatic,
					{
						"EventLocator", 
						"Event" -> {
							(Evaluate[(OptionValue[HorizonCondition])/.Rationalize[paramRules,10^-100]]/.{$v->x[1][\[Lambda]],$r->x[2][\[Lambda]],$\[Theta]->x[3][\[Lambda]],$\[Chi]->x[4][\[Lambda]]})
						}, 
						"EventAction" :> {
							(If[OptionValue[PrintTemporaryOption],PrintTemporary[
								"trajectory fell into user-defined horizon: at \[Lambda]="<>ToString[N[\[Lambda],5]]<>" the user-defined HorizonCondition has been numerically detected.",
								"Note that this essentially detects the observers image of the user-defined surface 'HorizonCondition'."
							]];
							Message[BoundaryBisectionInternal::HorizonCondition];
							Throw[Null,"StopIntegration"])
						}
					}
				],
				WorkingPrecision->OptionValue[WorkingPrecision], MaxSteps->\[Infinity]
			]],
			Null
		];
		(*PrintTemporary@If[sol===Null||Head@sol===String,"fell into","passed \[Infinity]"];*)
		If[
			sol===Null||Head@sol===String,
			BoundaryBisectionInternal[odes, inits, {\[Lambda],\[Lambda]Min,\[Lambda]Max}, {xScreen, yScreen}, {{xInnerScreen + (xOuterScreen-xInnerScreen)/2,yInnerScreen + (yOuterScreen-yInnerScreen)/2}, {xOuterScreen,yOuterScreen}}, paramRules, precisionAim, opts, PrintTemporaryOption->OptionValue[PrintTemporaryOption]],
			BoundaryBisectionInternal[odes, inits, {\[Lambda],\[Lambda]Min,\[Lambda]Max}, {xScreen, yScreen}, {{xInnerScreen,yInnerScreen}, {xInnerScreen + (xOuterScreen-xInnerScreen)/2,yInnerScreen + (yOuterScreen-yInnerScreen)/2}}, paramRules, precisionAim, opts, PrintTemporaryOption->OptionValue[PrintTemporaryOption]]
		]
		,
		Return[N[{xOuterScreen(*xInnerScreen + (xOuterScreen-xInnerScreen)/2*), yOuterScreen(*yInnerScreen + (yOuterScreen-yInnerScreen)/2*)}]],
		None
	]
];


Options[GetParametricShadowBoundary] := DeleteDuplicates@Join[{HorizonCondition->False},Options[BoundaryBisection]];

GetParametricShadowBoundary[{rCam_?RationalQ,\[Theta]Cam_?RationalQ,\[Phi]Cam_?RationalQ}, {xCenter_?RationalQ,yCenter_?RationalQ}, radialSweepDistance_?RationalQ, {\[Psi]min_?RationalQ,\[Psi]max_?RationalQ,\[Psi]stepSize_?RationalQ}, paramRules_, precisionAim_, opts:OptionsPattern[]] := Module[
	{
		\[Psi]table = Table[\[Psi]Val,{\[Psi]Val,\[Psi]min,\[Psi]max,\[Psi]stepSize}],
		return
	},
	
	DynamicModule[
		{
			counter=0,
			starttime = AbsoluteTime[],
			printValue1
		},
	
		PrintTemporary["boundary bisection in progress ... for image angle \[Psi]=", Dynamic[N@printValue1]];
		PrintTemporary["estimated remaining time for evaluation: ", Dynamic[DateDifference[DateList[starttime],DateList[starttime+((AbsoluteTime[] - starttime)/counter*(Length@\[Psi]table - counter))],{"Day","Hour","Minute","Second"}]]];

		return = {
			printValue1=#;
			counter = counter + 1;
			#,
			BoundaryBisection[
				{rCam,\[Theta]Cam,\[Phi]Cam},
				{{xCenter,yCenter}, Rationalize[N[{xCenter + Cos[#]*radialSweepDistance, yCenter + Sin[#]*radialSweepDistance},100],10^-100]}, 
				paramRules, 
				precisionAim,
				PrintTemporaryOption->False,
				opts
			]
		}&/@\[Psi]table;
	];

	return = {{N[#[[1]]],Sqrt[(#[[2,1]]-xCenter)^2 +  (#[[2,2]]-yCenter)^2]},#[[2]]}&/@return;
	
	Return@return;
];

GetParametricShadowBoundary[{rCam_,\[Theta]Cam_,\[Phi]Cam_}, {xCenter_,yCenter_}, radialSweepDistance_, {\[Psi]min_,\[Psi]max_,\[Psi]stepSize_}, paramRules_, precisionAim_, opts:OptionsPattern[]] := Module[{},
	Print["Input values of {rCam_,\[Theta]Cam_,\[Phi]Cam_}, radialSweepDistance, {xCenter_,yCenter_}, and/or {\[Psi]min_,\[Psi]max_,\[Psi]stepSize_} not recognized as infinite precision numbers. 
Please use rational input only as this improves the employed numerical methods. 
You can use Rationalize[input_,precision_]] where precision is the desired precision, e.g., 10^-100, to rationalize your numerical input."
	];
];


Options[RingBisection] := {PrintTemporaryOption->True};

RingBisection[{rCam_?RationalQ,\[Theta]Cam_?RationalQ,\[Phi]Cam_?RationalQ}, {{xInnerScreen_?RationalQ,yInnerScreen_?RationalQ}, {xOuterScreen_?RationalQ,yOuterScreen_?RationalQ}}, paramRules_, ringNumber_, precisionAim_, opts:OptionsPattern[]] := Module[
	{
		inits, xScreen, yScreen,odes,
		\[Lambda]Max= 3rCam,
		result, return
	},
	
	Switch[
		(*condition*)
		WhichCoords,
		(*option 1*)
		BoyerLindquist,
		odes = GetNullGeodesic1stOrderODE[x,k,\[Lambda]]/.{$t->x[1][\[Lambda]],$r->x[2][\[Lambda]],$\[Theta]->x[3][\[Lambda]],$\[Phi]->x[4][\[Lambda]]}/.Rationalize[paramRules,10^-100];
		inits = GetBoyerLindquistInitialValues[{x, k, 0},{rCam,\[Theta]Cam,\[Phi]Cam},{xScreen,yScreen},0]/.Rationalize[paramRules,10^-100];
		,
		(*option 2*)
		Kerr,
		odes = GetNullGeodesic1stOrderODE[x,k,\[Lambda]]/.{$v->x[1][\[Lambda]],$r->x[2][\[Lambda]],$\[Theta]->x[3][\[Lambda]],$\[Chi]->x[4][\[Lambda]]}/.Rationalize[paramRules,10^-100];
		inits = GetKerrInitialValues[{x, k, 0},{rCam,\[Theta]Cam,\[Phi]Cam},{xScreen,yScreen},$spin]/.Rationalize[paramRules,10^-100];
		,
		(*default other*)
		_,
		Print["Suitable coordinates not yet set. Please use either SetBoyerLindquistCoords[] or SetKerrCoords[] to set the coordinates. Other coordinates are not yet supported."];
		Return[Null]		
	];
	
	If[OptionValue[PrintTemporaryOption], PrintTemporary["light ring bisection in progress ... "]];
	result = RingBisectionInternal[odes, inits, {\[Lambda],0,\[Lambda]Max}, {xScreen, yScreen}, {{xInnerScreen,yInnerScreen}, {xOuterScreen,yOuterScreen}}, paramRules, ringNumber, precisionAim, opts, PrintTemporaryOption->OptionValue[PrintTemporaryOption]];

	If[
		Or[
			(xOuterScreen - result[[1]])^2 + (yOuterScreen - result[[2]])^2 < 2*precisionAim^2,
			(xInnerScreen - result[[1]])^2 + (yInnerScreen - result[[2]])^2 < 2*precisionAim^2
		]
		,
		If[OptionValue[PrintTemporaryOption], Print["probably no "<>ToString@ringNumber<>"-th light ring between the two specified points."]];
		return = None;
		,
		If[OptionValue[PrintTemporaryOption], Print["Light-ring boundary number "<>ToString@ringNumber<>" was found within the specified interval."]];
		return = result;
	];

	Return@return;
];

RingBisection[{rCam_,\[Theta]Cam_,\[Phi]Cam_}, {{xInnerScreen_,yInnerScreen_}, {xOuterScreen_,yOuterScreen_}}, paramRules_, ringNumber_, precisionAim_, opts:OptionsPattern[]] := Module[{},
	Print["Input values of {rCam_,\[Theta]Cam_,\[Phi]Cam_} and/or {{xInnerScreen_,yInnerScreen_}, {xOuterScreen_,yOuterScreen_}} not recognized as infinite precision numbers. 
Please use rational input only as this improves the employed numerical methods. 
You can use Rationalize[input_,precision_]] where precision is the desired precision, e.g., 10^-100, to rationalize your numerical input."
	];
];


Options[RingBisectionInternal] := Options[RingBisection];

RingBisectionInternal::HorizonCondition="Trajectory fell into user-defined horizon.";

RingBisectionInternal[odes_, inits_, {\[Lambda]_,\[Lambda]Min_,\[Lambda]Max_}, {xScreen_, yScreen_}, {{xInnerScreen_,yInnerScreen_}, {xOuterScreen_,yOuterScreen_}}, paramRules_, ringNumber_, precisionAim_, opts:OptionsPattern[]] := Module[
	{
		sol,
		count
	},
	If[OptionValue[PrintTemporaryOption], 
		PrintTemporary["current bisection: x \[Element] [",N@xInnerScreen,", ",N@xOuterScreen,"] and y \[Element] [",N@yInnerScreen,", ",N@yOuterScreen,"]."];
	];
	If[
		(xOuterScreen-xInnerScreen)^2 + (yOuterScreen-yInnerScreen)^2 > precisionAim^2
		,
		count = -2;
		sol = NDSolve[
			Join[
				odes,
				inits/.{xScreen -> xInnerScreen + (xOuterScreen-xInnerScreen)/2, yScreen -> yInnerScreen + (yOuterScreen-yInnerScreen)/2}
			],
			{x[1][\[Lambda]],x[2][\[Lambda]],x[3][\[Lambda]],x[4][\[Lambda]],k[1][\[Lambda]],k[2][\[Lambda]],k[3][\[Lambda]],k[4][\[Lambda]]},{\[Lambda],\[Lambda]Min,\[Lambda]Max},
			Method -> {
				"EventLocator", 
				"Event" -> {
					(Evaluate[(D[x[3][\[Lambda]],\[Lambda]]==0)/.Rationalize[paramRules,10^-100]]/.{$v->x[1][\[Lambda]],$r->x[2][\[Lambda]],$\[Theta]->x[3][\[Lambda]],$\[Chi]->x[4][\[Lambda]]}),
					(Evaluate[$r<0.5/.Rationalize[paramRules,10^-100]]/.{$v->x[1][\[Lambda]],$r->x[2][\[Lambda]],$\[Theta]->x[3][\[Lambda]],$\[Chi]->x[4][\[Lambda]]})
				}, 
				"EventAction" :> {
					(count = count + 1;
					If[OptionValue[PrintTemporaryOption],PrintTemporary["light-ring count increased to ",N@count" at radius r=",N@x[2][\[Lambda]]] ];),
					(count = \[Infinity];
					If[OptionValue[PrintTemporaryOption],PrintTemporary["small radius cutoff hit ... stop integrating and increase bisection"]];
					Throw[Null,"StopIntegration"])
				}
			}
			,
			WorkingPrecision->30, MaxSteps->1000000
		];
		If[
			count>=ringNumber,
			RingBisectionInternal[odes, inits, {\[Lambda],\[Lambda]Min,\[Lambda]Max}, {xScreen, yScreen}, {{xInnerScreen + (xOuterScreen-xInnerScreen)/2,yInnerScreen + (yOuterScreen-yInnerScreen)/2}, {xOuterScreen,yOuterScreen}}, paramRules, ringNumber, precisionAim, opts, PrintTemporaryOption->OptionValue[PrintTemporaryOption]],
			RingBisectionInternal[odes, inits, {\[Lambda],\[Lambda]Min,\[Lambda]Max}, {xScreen, yScreen}, {{xInnerScreen,yInnerScreen}, {xInnerScreen + (xOuterScreen-xInnerScreen)/2,yInnerScreen + (yOuterScreen-yInnerScreen)/2}}, paramRules, ringNumber, precisionAim, opts, PrintTemporaryOption->OptionValue[PrintTemporaryOption]]
		]
		,
		Return[N[{xInnerScreen + (xOuterScreen-xInnerScreen)/2, yInnerScreen + (yOuterScreen-yInnerScreen)/2}]]
		,
		None
	]
];


Options[GetParametricLightRingBoundary] := {HorizonCondition->False};

GetParametricLightRingBoundary[{rCam_?RationalQ,\[Theta]Cam_?RationalQ,\[Phi]Cam_?RationalQ}, {xCenter_?RationalQ,yCenter_?RationalQ}, radialSweepDistance_?RationalQ, {\[Psi]min_?RationalQ,\[Psi]max_?RationalQ,\[Psi]stepSize_?RationalQ}, paramRules_, ringNumber_, precisionAim_, opts:OptionsPattern[]] := Module[
	{
		\[Psi]table = Table[\[Psi]Val,{\[Psi]Val,\[Psi]min,\[Psi]max,\[Psi]stepSize}],
		xBoundary, yBoundary,
		return
	},
	
	DynamicModule[
		{
			counter=0,
			starttime = AbsoluteTime[],
			printValue1
		},
	
		PrintTemporary["light ring bisection (including internal determination of a shadow bisection) in progress ... for image angle \[Psi]=", Dynamic[N@printValue1]];
		PrintTemporary["or in terms of coordinates between (xMin, yMin) = ", {xCenter,yCenter}, " and (xMax, yMax) = ",Dynamic[N@{xCenter + Cos[printValue1]*radialSweepDistance, yCenter + Sin[printValue1]*radialSweepDistance}]];
		PrintTemporary["estimated remaining time for evaluation: ", Dynamic[DateDifference[DateList[starttime],DateList[starttime+((AbsoluteTime[] - starttime)/counter*(Length@\[Psi]table - counter))],{"Day","Hour","Minute","Second"}]]];

		return = {
			printValue1=#;
			counter = counter + 1;
			#,
			{xBoundary,yBoundary} = BoundaryBisection[
				{rCam,\[Theta]Cam,\[Phi]Cam},
				{{xCenter,yCenter}, Rationalize[N[{xCenter + Cos[#]*radialSweepDistance, yCenter + Sin[#]*radialSweepDistance},100],10^-100]}, 
				paramRules, 
				precisionAim,
				PrintTemporaryOption->False,
				opts
			],
			RingBisection[
				{rCam,\[Theta]Cam,\[Phi]Cam},
				{Rationalize[{xBoundary,yBoundary},1*^-100], Rationalize[N[{xCenter + Cos[#]*radialSweepDistance, yCenter + Sin[#]*radialSweepDistance},100],10^-100]}, 
				paramRules, 
				ringNumber,
				precisionAim,
				PrintTemporaryOption->False,
				opts
			]
		}&/@\[Psi]table;
	];

	return = {
		{{N[#[[1]]],Sqrt[(#[[2,1]]-xCenter)^2 +  (#[[2,2]]-yCenter)^2]},#[[2]]}&/@return,
		{{N[#[[1]]],Sqrt[(#[[3,1]]-xCenter)^2 +  (#[[3,2]]-yCenter)^2]},#[[3]]}&/@return
	};
	
	Return@return;
];

GetParametricLightRingBoundary[{rCam_,\[Theta]Cam_,\[Phi]Cam_}, {xCenter_,yCenter_}, radialSweepDistance_, {\[Psi]min_,\[Psi]max_,\[Psi]stepSize_}, paramRules_, ringNumber_, precisionAim_, opts:OptionsPattern[]] := Module[{},
	Print["Input values of {rCam_,\[Theta]Cam_,\[Phi]Cam_}, radialSweepDistance, {xCenter_,yCenter_}, and/or {\[Psi]min_,\[Psi]max_,\[Psi]stepSize_} not recognized as infinite precision numbers. 
Please use rational input only as this improves the employed numerical methods. 
You can use Rationalize[input_,precision_]] where precision is the desired precision, e.g., 10^-100, to rationalize your numerical input."
	];
];


Options[GetRadiativeTransferEquationForDiskModel] := {DiskCutoff->False}

GetRadiativeTransferEquationForDiskModel::uNorm = "velocity u is not appropriately normalized";

GetRadiativeTransferEquationForDiskModel[{A_,alpha_,h_,l0_}, opts:OptionsPattern[]] := Module[
	{
		u,
		uu,
		uBar,
		RR,
		ll,
		qq=1/2,
		beta=5/2,
		\[Nu]\[Nu],
		\[Nu]p=1,
		nn,
		n0=3(**10^-18*),
		j\[Nu],
		\[Alpha]\[Nu],
		ode,
		toRayCoordsRule = Switch[
				WhichCoords,
				BoyerLindquist,
				{$t->x[1][\[Lambda]],$r->x[2][\[Lambda]],$\[Theta]->x[3][\[Lambda]],$\[Phi]->x[4][\[Lambda]]},
				Kerr,
				Join[GetBoyerLindquistToKerrCoordsRule[],{$v->x[1][\[Lambda]],$r->x[2][\[Lambda]],$\[Theta]->x[3][\[Lambda]],$\[Chi]->x[4][\[Lambda]]}],
				_,Print["Suitable coordinates not yet set. Please use either SetBoyerLindquistCoords[] or SetKerrCoords[] to set the coordinates. Other coordinates are not yet supported."];Break[];
			]
	},
	(*set some (ray-dependent) constants*)
	RR := $r*Sin[$\[Theta]];
	
	ll := - (l0/(1+RR))RR^(1+qq); (*not clear to me where this minus sign comes from but it is necessary in order to match the EXACT_GRRT models*)
	
	(*define fluid velocity vector of the disk*)
	Switch[
		WhichCoords
		,
		BoyerLindquist
		,
		(*fluid velocity in BL coordinates as in Eq.~(8) in EHT_GRRT code comparison*)
		u = {-1,0,0,ll};
		,
		Kerr
		,
		(*implement the covariant fluid velocity transformed from BL into ingoing Kerr coordinates*)
		(*derivation given in SpimpleRayTracer/literature/fluid-velocity_BL-toingoingKerr-trafo.pdf*)
		u = {-1,($r^2+$spin (-ll+$spin))/($r^2- 2 $G0 $mass $r + $spin^2),0,ll}
		,
		_
		,
		Print["Suitable coordinates not yet set. Please use either SetBoyerLindquistCoords[] or SetKerrCoords[] to set the coordinates. Other coordinates are not yet supported."];Break[];
	];
	(*normalize the fluid velocity using the implemented metric*)
	uu = 1/Sqrt[Simplify[-Sum[GetMetric[i,j]u[[i]]u[[j]],{i,1,4},{j,1,4}],Trig->False,TimeConstraint->5]] u;
	
	(*confirm that the velocity is appropriately normalized*)
	If[!(Simplify[Sum[-GetMetric[i,j]uu[[i]]uu[[j]],{i,1,4},{j,1,4}]//.toRayCoordsRule]===1),Message[GetRadiativeTransferEquationForDiskModel::uNorm, None]];
	PrintTemporary["fluid velocity normalized and simplified"];

	(*from that one can define the frequency*)		
	\[Nu]\[Nu] := Sum[-uu[[i]]k[i][\[Lambda]],{i,1,4}];
	
	(*calculate number density*)
	(*depening on option value set a cutoff of the disk at classical horizon values*)
	nn := Simplify[n0 Exp[-(1/2)(($r/10)^2 + (h*Cos[$\[Theta]])^2)]*If[OptionValue[DiskCutoff],SmoothHeaviside[$r - ($mass + Sqrt[$mass^2 - $spin^2]), 10^4],1,1],Trig->False];
	
	(*calculate emissivity*)
	j\[Nu] := nn (\[Nu]\[Nu]/\[Nu]p)^(-alpha);
	
	(*calculate absorbtivity*)
	\[Alpha]\[Nu] := A*nn (\[Nu]\[Nu]/\[Nu]p)^(-(beta+alpha));
	(*integrate intensity*)
	ode = (D[I\[Nu]\[Nu]3[\[Lambda]],\[Lambda]] == Max[Min[Simplify[j\[Nu]/\[Nu]\[Nu]^2,Trig->False] - If[A==0,0,Simplify[\[Nu]\[Nu]*\[Alpha]\[Nu]*I\[Nu]\[Nu]3[\[Lambda]],Trig->False]],10^5],-10^5])//.toRayCoordsRule;
	Return[ode]
];


Options[GetIntensity] := DeleteDuplicates@Join[Options[NDSolve],Options[GetSingleLightRay],{StopIntegrationAtLightRingNumber->False,RadiativeTransferMaxStepSize->Automatic}];

GetIntensity[{rCam_?RationalQ,\[Theta]Cam_?RationalQ,\[Phi]Cam_?RationalQ},{xScreen_?RationalQ,yScreen_?RationalQ},paramRules_List, ode_, opts:OptionsPattern[]] := Module[
	{
		ray,
		intensity,
		\[Lambda]Min,\[Lambda]Max,\[Lambda]Hor,\[Lambda]HorRule,
		count
	}
	,
	
	(*get the current ray*)
	ray = GetSingleLightRay[
		{rCam,\[Theta]Cam,\[Phi]Cam},{xScreen,yScreen},paramRules,
		WorkingPrecision->OptionValue[WorkingPrecision],PrecisionGoal->Automatic,HorizonCondition->OptionValue[HorizonCondition]
	][[1]];
	
	(*get parameterized start and end point*)
	\[Lambda]Min = Head[ray[[1,2]]][[1,1,1]];
	\[Lambda]Max = Head[ray[[1,2]]][[1,1,2]];
	(*Print@{\[Lambda]Min,\[Lambda]Max};*)
	
	(*find the (Killing or user-defined) horizon value of \[Lambda]*)	
	\[Lambda]HorRule = Quiet@FindRoot[
		If[
			TrueQ[!OptionValue[HorizonCondition]],
			GetMetric[2,2]==0,
			Replace[OptionValue[HorizonCondition],{Less[a_,b_]:>Plus[a,-b], LessEqual[a_,b_]:>Plus[a,-b], Greater[a_,b_]:>Plus[a,-b], GreaterEqual[a_,b_]:>Plus[a,-b]}]
		]/.paramRules/.{$r->x[2][\[Lambda]],$\[Theta]->x[3][\[Lambda]]}/.ray,
		{\[Lambda],(\[Lambda]Min+\[Lambda]Max)/2,\[Lambda]Min,\[Lambda]Max}
	];
	(*Print@\[Lambda]HorRule;*)
	(*(to be improved) in case of Killing-horzon condition the above FindRoot is a bit tricky/problematic because it tends to find inner horizons ... hence we try again*)
	If[
		TrueQ[!OptionValue[HorizonCondition]],
		\[Lambda]HorRule = Quiet@FindRoot[
			GetMetric[2,2]==0/.paramRules/.{$r->x[2][\[Lambda]],$\[Theta]->x[3][\[Lambda]]}/.ray,
			{\[Lambda],Evaluate[\[Lambda]/.\[Lambda]HorRule]-(\[Lambda]Min+Evaluate[\[Lambda]/.\[Lambda]HorRule])/rCam,\[Lambda]Min,Evaluate[\[Lambda]/.\[Lambda]HorRule]-(\[Lambda]Min+Evaluate[\[Lambda]/.\[Lambda]HorRule])/(rCam*10)}
		]
	];
	(*Print@\[Lambda]HorRule;*)
	(*if Killing (or user-defined) horizon was found, integrate from there. if not, integrate from large radial distance*)
	If[
		Evaluate[If[
			TrueQ[!OptionValue[HorizonCondition]],
			GetMetric[2,2],
			Replace[OptionValue[HorizonCondition],{Less[a_,b_]:>Plus[a,-b], LessEqual[a_,b_]:>Plus[a,-b], Greater[a_,b_]:>Plus[a,-b], GreaterEqual[a_,b_]:>Plus[a,-b]}]
		]/.paramRules/.{$r->x[2][\[Lambda]],$\[Theta]->x[3][\[Lambda]]}/.ray/.\[Lambda]HorRule] < 1*^-5
		, 
		\[Lambda]Hor = \[Lambda]/.\[Lambda]HorRule;
		Print[If[TrueQ[!OptionValue[HorizonCondition]],"Killing","User-defined"]<>" horizon at r=",N[x[2][\[Lambda]]/.ray/.\[Lambda]->\[Lambda]Hor]," detected for \[Lambda]=",N@\[Lambda]Hor];
		, 
		\[Lambda]Hor=\[Lambda]Max;
		Print["No event horizon found. Will start intensity integration from \[Lambda]Max=",N@\[Lambda]Hor];
		,
		\[Lambda]Hor=\[Lambda]Max;
		Print["No event horizon found. Will start intensity integration from \[Lambda]Max=",N@\[Lambda]Hor];
	];
	
	(*PrintTemporary[Plot[x[3][\[Lambda]]/.ray,{\[Lambda],\[Lambda]Min,\[Lambda]Hor},PlotRange\[Rule]Full]];*)
	(*integrate intensity via NDSolve using user-specified WorkingPrecision and PrecisionGoal*)
	
	count=0;
	intensity = Quiet[First[NDSolve[
		{ode/.paramRules/.ray, I\[Nu]\[Nu]3[\[Lambda]Min]==0},
		I\[Nu]\[Nu]3[\[Lambda]],
		{\[Lambda],\[Lambda]Min,\[Lambda]Hor},
		WorkingPrecision->11/10*OptionValue[WorkingPrecision], MaxSteps->\[Infinity], PrecisionGoal->OptionValue[PrecisionGoal],
		MaxStepSize->OptionValue[RadiativeTransferMaxStepSize],
		Method -> If[NumberQ[OptionValue[StopIntegrationAtLightRingNumber]]
			,
			{
				"EventLocator", 
				"Event" -> {
					(*(Evaluate[Mod[$\[Theta],\[Pi]]\[Equal]\[Pi]/2/.Rationalize[paramRules,10^-100]]/.{$v\[Rule]x[1][\[Lambda]],$r\[Rule]x[2][\[Lambda]],$\[Theta]\[Rule]x[3][\[Lambda]],$\[Chi]\[Rule]x[4][\[Lambda]]}/.ray)*)
					(Evaluate[D[x[3][\[Lambda]]/.ray,\[Lambda]]==0])
				}, 
				"EventAction" :> {(
					count = count + 1;
					(*PrintTemporary[Evaluate[$\[Theta]/.Rationalize[paramRules,10^-100]]/.{$v\[Rule]x[1][\[Lambda]],$r\[Rule]x[2][\[Lambda]],$\[Theta]\[Rule]x[3][\[Lambda]],$\[Chi]\[Rule]x[4][\[Lambda]]}/.ray];*)
					(If[OptionValue[PrintTemporaryOption],PrintTemporary["light-ring count increased to ",N@count" at \[Theta]=",N[x[3][\[Lambda]]/.ray]]];)
					If[
						(Evaluate[count>OptionValue[StopIntegrationAtLightRingNumber]]),
						If[OptionValue[PrintTemporaryOption],PrintTemporary["integration stopped at user-selected light-ring number ",OptionValue[StopIntegrationAtLightRingNumber]]];
					Throw[Null,"StopIntegration"]
					];
				)}
			},
			Automatic
		]
	]],{InterpolatingFunction::dmval,General::munfl}];
	
	(*not even sure how it can happen that NDSolve does not reach boundary without warning but it does occur -- stupid Mathematica*)
	(*we only give a temporary warning since the endpoint is, in all observed cases to date, still close to the screen but this could result in issues*)
	Quiet@If[
		\[Lambda]Hor > Head[intensity[[1,2]]][[1,1,2]] && !NumberQ[OptionValue[StopIntegrationAtLightRingNumber]],
		PrintTemporary["numerical integration did not reach screen but stalled at ", Head[intensity[[1,2]]][[1,1,2]]];
	];
	
	intensity = Quiet[I\[Nu]\[Nu]3[\[Lambda]]/.intensity/.{\[Lambda]->Min[\[Lambda]Hor,Head[intensity[[1,2]]][[1,1,2]]]},{InterpolatingFunction::dmval,General::munfl}];
	Return[intensity];
];

SetOptions[GetIntensity, WorkingPrecision->20];
SetOptions[GetIntensity, PrecisionGoal->6];


Options[GetIntensityData] := Options[GetIntensity];

GetIntensityData[{rCam_?RationalQ,\[Theta]Cam_?RationalQ,\[Phi]Cam_?RationalQ}, paramRules_List, screenPoints_List, ode_, opts:OptionsPattern[]] := Module[
	{
		return
	},
	
	DynamicModule[
		{
			counter=0,
			starttime = AbsoluteTime[],
			currentImagePoint = screenPoints[[1]]
		},
	
		PrintTemporary["numerical integration of radiative transfer equation in progress ... for image point (x=", Dynamic[N@currentImagePoint[[1]]], ", y=", Dynamic[N@currentImagePoint[[2]]], ")"];
		PrintTemporary["estimated remaining time for evaluation: ", Dynamic[DateDifference[DateList[starttime],DateList[starttime+((AbsoluteTime[] - starttime)/counter*(Length@screenPoints - counter))],{"Day","Hour","Minute","Second"}]]];

		return = Block[{Print},
			{
				counter = counter+1;
				currentImagePoint = #;
				Sequence@@Flatten@#,
				Check[
					GetIntensity[{rCam,\[Theta]Cam,\[Phi]Cam},#,paramRules,ode,opts]
					,
					PrintTemporary["Image point (x,y)=", #," caused some error message throw -- check GetIntensity[] of single point to see error messages."]; 
					None
				]
			}&/@RandomSample[screenPoints]
		];
	];
	
	If[
		Count[return,{_,_,_?NumericQ}] < Length@screenPoints, 
		Print["Numerical integration of the radiative transfer equation did not converge for ", Length@screenPoints-Count[return,{_,_,_?NumericQ}], "/", Length@screenPoints," screen points. Try to incrase WorkinPrecision and test single points to see error messages."]
	];
	
	return
];

(*make a version that automatically uses disk model 3 from EXACT_GRRT comparison*)
GetIntensityData[{rCam_?RationalQ,\[Theta]Cam_?RationalQ,\[Phi]Cam_?RationalQ}, paramRules_List, screenPoints_List, opts:OptionsPattern[]] := Module[
	{
		A = 0, alpha = 0, h = 10/3, l0 = -1,
		ode
	},
	
	(*instantiate the disk model*)
	ode = GetRadiativeTransferEquationForDiskModel[{A,alpha,h,l0}];
	
	GetIntensityData[{rCam,\[Theta]Cam,\[Phi]Cam}, paramRules, screenPoints, ode, opts]
]


End[];


EndPackage[];
